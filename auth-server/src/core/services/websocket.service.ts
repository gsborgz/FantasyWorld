/*
  ATENÇÃO: Arquivo gerado pelo Copilot conforme solicitado.
  Propósito: Serviço WebSocket para sondagem (ping) e envio/espera de mensagens
  com tempo limite, garantindo encerramento limpo da conexão e resiliência
  contra mensagens inválidas. Útil para verificar disponibilidade de servidores
  e realizar interações simples baseadas em predicado de resposta.

  Visão geral:
  - ping(url): envia PING e aguarda PONG dentro de um timeout.
  - sendAndWait(url, payload, responsePredicate): abre WS, envia payload,
    aguarda mensagem que satisfaça o predicado e encerra a conexão de forma segura.
  - addProbeFlag(url): garante sinalização de "probe=1" na query string.
  - parseMessage(data): faz parse defensivo do payload de mensagem.
  - closeConnection(ws): remove listeners e fecha a conexão de forma idempotente.
*/
/*
  NOTE: File generated by Copilot as requested.
  Purpose: WebSocket service for probing (ping) and send/wait with a timeout,
  ensuring clean connection teardown and resilience against invalid messages.
  Useful for checking server availability and simple predicate-based interactions.

  Overview:
  - ping(url): sends PING and waits for PONG within a timeout.
  - sendAndWait(url, payload, responsePredicate): opens WS, sends payload,
    waits for a message that satisfies the predicate, then closes safely.
  - addProbeFlag(url): adds "probe=1" query flag.
  - parseMessage(data): defensive JSON parsing.
  - closeConnection(ws): removes listeners and closes idempotently.
*/
import { Injectable } from '@nestjs/common';
import { WebSocket } from 'ws';
import { WebsocketEvents, WebsocketMessage } from '../../shared/ws-utils';

export interface IWsSendOptions {
  timeoutMs?: number;
}


@Injectable()
export class WebsocketService {

  public async ping(url: string, timeoutMs = 2000): Promise<{ ok: boolean; message?: WebsocketMessage<any>; error?: any }> {
    const payload = { type: WebsocketEvents.PING };
    const probeUrl = this.addProbeFlag(url);

    return this.sendAndWait(probeUrl, payload, (m) => m && m.type === WebsocketEvents.PONG, { timeoutMs });
  }

  // Padrão "solicitação-resposta" via WebSocket com tempo limite e predicado:
  // - Abre conexão, envia payload serializado
  // - Ouve mensagens e resolve quando o predicado é satisfeito
  // - Sempre limpa timeout e fecha conexão ao resolver (sucesso/erro)
  private async sendAndWait<T = any>(
    url: string,
    payload: unknown,
    responsePredicate: (msg: any) => boolean,
    options?: IWsSendOptions,
  ): Promise<{ ok: boolean; message?: T; error?: any }> {
    const timeoutMs = options?.timeoutMs ?? 2000;

    return new Promise((resolve) => {
      let isResolved = false;
      let connection: WebSocket | null = null;
      let timeoutHandle: NodeJS.Timeout | null = null;
      // resolveOnce: garante resolução única e encerra recursos de forma segura
      const resolveOnce = (ok: boolean, message?: T, error?: any) => {
        if (isResolved) return;

        isResolved = true;

        if (timeoutHandle) clearTimeout(timeoutHandle);

        this.closeConnection(connection);
        resolve({ ok, message, error });
      };

      try {
        connection = new WebSocket(url);
      } catch (_err) {
        resolveOnce(false, undefined, _err);

        return;
      }

      // Dispara falha por timeout caso não haja resposta dentro do prazo
      timeoutHandle = setTimeout(() => resolveOnce(false, undefined, new Error('timeout')), timeoutMs);

      // Ao abrir, serializa e envia o payload (defensivo contra falhas JSON)
      connection.on('open', () => {
        try {
          const serialized = JSON.stringify(payload);

          connection!.send(serialized);
        } catch (_err) {
          resolveOnce(false, undefined, _err);
        }
      });

      // Ao receber mensagem, faz parse defensivo e aplica o predicado
      connection.on('message', (data) => {
        const msg = this.parseMessage(data);

        if (msg === undefined) return;

        try {
          if (responsePredicate(msg)) {
            resolveOnce(true, msg);
          }
        } catch (_err) {
          // predicate threw; treat as non-match and continue
        }
      });

      // Erros de transporte resolvem a promessa com falha
      connection.on('error', (_err) => {
        resolveOnce(false, undefined, _err);
      });

      connection.on('close', () => {
        // if closed before resolved, the timeout/error will handle resolution
      });
    });
  }

  private addProbeFlag(url: string): string {
    try {
      const urlObj = new URL(url);
      // Don't override existing probe flag if present
      
      if (!urlObj.searchParams.has('probe')) {
        urlObj.searchParams.set('probe', '1');
      }

      return urlObj.toString();
    } catch {
      // Fallback for relative/invalid URLs: naive append
      
      if (url.includes('?')) return `${url}&probe=1`;

      return `${url}?probe=1`;
    }
  }

  // Encerra conexão com segurança e remove todos os listeners
  private closeConnection(connection: WebSocket | null): void {
    try {
      if (connection) {
        connection.removeAllListeners?.();
        connection.close();
      }
    } catch {
      // ignore
    }
  }

  // Parse de mensagem tolerante a erros: retorna undefined se não for JSON válido
  private parseMessage(data: any): any | undefined {
    try {
      return JSON.parse(data?.toString?.() ?? data);
    } catch {
      return undefined;
    }
  }

}

