/*
  ATENÇÃO: Arquivo gerado pelo Copilot conforme solicitado.
  Propósito: Script de construção que converte tipos e estruturas
  compartilhadas em TypeScript para artefatos consumíveis pelo cliente Godot
  (.gd) e também normaliza/copía arquivos para o auth-server (src/shared).

  Visão geral de pipeline:
  - Para o client: lê TS em src/shared, gera enums/classes/dicts/arrays/funções
    em GDScript e grava em client/shared.
  - Para o auth-server: normaliza arquivo TS (remove comentários, achata
    classes com 'extends', converte type aliases em classes, garante ponto e
    vírgula em export const, formata), e copia para auth-server/src/shared.

  Notas de manutenção:
  - As transformações são conservadoras e evitam mudar semântica; foco em
    compatibilidade entre projetos (Godot e NestJS) e previsibilidade.
  - Partes complexas possuem comentários explicativos adicionais logo abaixo.
*/
/*
  NOTE: File generated by Copilot as requested.
  Purpose: Build script that converts shared TypeScript types/structures into
  Godot-consumable artifacts (.gd) and also normalizes/copies files to the
  auth-server (src/shared).

  Pipeline overview:
  - Client: read TS from src/shared, emit enums/classes/dicts/arrays/functions
    to GDScript under client/shared.
  - Auth-server: normalize TS (strip comments, flatten 'extends' classes,
    transform type aliases into classes, ensure semicolons in export const,
    format), then copy to auth-server/src/shared.

  Maintenance notes:
  - Transformations are conservative to preserve semantics and favor
    compatibility between projects (Godot and NestJS).
  - Complex parts include extra inline comments below for clarity.
*/
import * as fs from 'fs';
import * as path from 'path';

const SHARED_DIR = path.resolve(__dirname, '../src/shared');
const OUTPUT_DIR = path.resolve(__dirname, '../../client/shared');
const AUTH_SHARED_DIR = path.resolve(__dirname, '../../auth-server/src/shared');

function writeFileIfChanged(outPath: string, content: string) {
  const exists = fs.existsSync(outPath);
  if (exists) {
    const current = fs.readFileSync(outPath, 'utf-8');
    if (current === content) {
      console.log(`Sem alterações: ${outPath}`);
      return false;
    }
  }
  fs.writeFileSync(outPath, content, 'utf-8');
  console.log(`${exists ? 'Atualizado' : 'Gerado'}: ${outPath}`);
  return true;
}

function copyFileIfChanged(src: string, dest: string) {
  // Pipeline de normalização para auth-server:
  // 1) stripComments: remove comentários para reduzir ruído;
  // 2) flattenExtendedClasses: substitui 'extends' gerando classe plana com props mescladas;
  // 3) transformTypeAliasesToClassesForAuth: converte 'type Alias = Target' (e interseção) em classes;
  // 4) addSemicolonsForConstDeclarations: garante ';' após objetos/arrays exportados;
  // 5) formatForAuthServer: aplica pequenos ajustes de espaçamento/linhas.
  const srcContent = fs.readFileSync(src, 'utf-8');
  const stripped = stripComments(srcContent);
  const flattened = flattenExtendedClasses(stripped, src);
  const withTypesAsClasses = transformTypeAliasesToClassesForAuth(flattened, src);
  const withSemicolons = addSemicolonsForConstDeclarations(withTypesAsClasses);
  const formatted = formatForAuthServer(withSemicolons);
  const exists = fs.existsSync(dest);
  if (exists) {
    const destContent = fs.readFileSync(dest, 'utf-8');
    if (destContent === formatted) {
      console.log(`Sem alterações (auth-server): ${dest}`);
      return false;
    }
  }
  fs.writeFileSync(dest, formatted, 'utf-8');
  console.log(`${exists ? 'Atualizado' : 'Copiado'} para auth-server: ${dest}`);
  return true;
}

function collectTsClassProps(ts: string, className: string, filePath: string, seen: Set<string> = new Set()): Array<{ name: string; type: string; optional: boolean }> {
  if (seen.has(className)) return [];
  seen.add(className);
  const importMap = buildImportMap(ts);
  const declRegex1 = new RegExp(`export\\s+class\\s+${className}([^\\{]*)\\{`);
  const declRegex2 = new RegExp(`(^|\n)class\\s+${className}([^\\{]*)\\{`);
  const declMatch = ts.match(declRegex1) || ts.match(declRegex2);
  const body = getClassBody(ts, className) ?? '';
  const own = extractTsProps(body);
  let merged = [...own];
  if (declMatch) {
    const declTail = declMatch[1];
    const baseMatch = declTail.match(/extends\s+(\w+)/);
    if (baseMatch) {
      const baseName = baseMatch[1];
      let baseProps: Array<{ name: string; type: string; optional: boolean }> = [];
      const rel = importMap.get(baseName);
      if (rel) {
        const resolved = path.resolve(path.dirname(filePath), rel.endsWith('.ts') ? rel : rel + '.ts');
        if (fs.existsSync(resolved)) {
          const baseContent = fs.readFileSync(resolved, 'utf-8');
          baseProps = collectTsClassProps(baseContent, baseName, resolved, seen);
        }
      } else {
        baseProps = collectTsClassProps(ts, baseName, filePath, seen);
      }
      const map = new Map<string, { type: string; optional: boolean }>();
      for (const p of baseProps) map.set(p.name, { type: p.type, optional: p.optional });
      for (const p of merged) map.set(p.name, { type: p.type, optional: p.optional });
      merged = Array.from(map.entries()).map(([name, v]) => ({ name, type: v.type, optional: v.optional }));
    }
  }
  return merged;
}

function transformTypeAliasesToClassesForAuth(ts: string, filePath: string): string {
  // Converte aliases de tipo em classes concretas para uso no auth-server.
  // Motivo: alguns consumidores (e etapas de copy) precisam de declarações
  // de classe explícitas, evitando ambiguidade e simplificando parsing.
  // Converte aliases simples e interseções (Target & { props }) em classes exportadas.
  let out = ts;
  const replacements: Array<{ start: number; end: number; text: string }> = [];
  const importsToRemove: Array<{ targetName: string; importRel: string }> = [];
  const importMap = buildImportMap(ts);

  // Aliases simples: export type A = B;
  const simpleAliasRegex = /export\s+type\s+(\w+)\s*=\s*(\w+)\s*;/g;
  let match: RegExpExecArray | null;
  while ((match = simpleAliasRegex.exec(ts)) !== null) {
    const full = match[0];
    const aliasName = match[1];
    const targetName = match[2];
    const importRel = importMap.get(targetName);
    let props: Array<{ name: string; type: string; optional: boolean }> = [];
    if (importRel) {
      const resolved = path.resolve(path.dirname(filePath), importRel.endsWith('.ts') ? importRel : importRel + '.ts');
      if (fs.existsSync(resolved)) {
        const targetContent = fs.readFileSync(resolved, 'utf-8');
        props = collectTsClassProps(targetContent, targetName, resolved);
      }
      importsToRemove.push({ targetName, importRel });
    } else {
      const body = getClassBody(ts, targetName);
      if (body) props = collectTsClassProps(ts, targetName, filePath);
    }
    if (props.length === 0) continue;
    let classText = `export class ${aliasName} {\n`;
    for (const p of props) classText += `  ${p.name}${p.optional ? '?' : ''}: ${p.type};\n`;
    classText += `}`;
    replacements.push({ start: match.index, end: match.index + full.length, text: classText });
  }

  // Aliases com interseção: export type A = B & { ... };
  const intersectionAliasRegex = /export\s+type\s+(\w+)\s*=\s*(\w+)\s*&\s*{([\s\S]*?)}\s*;/g;
  while ((match = intersectionAliasRegex.exec(ts)) !== null) {
    const full = match[0];
    const aliasName = match[1];
    const targetName = match[2];
    const inlineBody = match[3];
    const importRel = importMap.get(targetName);
    let targetProps: Array<{ name: string; type: string; optional: boolean }> = [];
    if (importRel) {
      const resolved = path.resolve(path.dirname(filePath), importRel.endsWith('.ts') ? importRel : importRel + '.ts');
      if (fs.existsSync(resolved)) {
        const targetContent = fs.readFileSync(resolved, 'utf-8');
        targetProps = collectTsClassProps(targetContent, targetName, resolved);
      }
      importsToRemove.push({ targetName, importRel });
    } else {
      const body = getClassBody(ts, targetName);
      if (body) targetProps = collectTsClassProps(ts, targetName, filePath);
    }
    const extraProps = extractTsProps(inlineBody);
    const mergedMap = new Map<string, { type: string; optional: boolean }>();
    for (const p of targetProps) mergedMap.set(p.name, { type: p.type, optional: p.optional });
    for (const p of extraProps) mergedMap.set(p.name, { type: p.type, optional: p.optional });
    const merged = Array.from(mergedMap.entries()).map(([name, v]) => ({ name, type: v.type, optional: v.optional }));
    if (merged.length === 0) continue;
    let classText = `export class ${aliasName} {\n`;
    for (const p of merged) classText += `  ${p.name}${p.optional ? '?' : ''}: ${p.type};\n`;
    classText += `}`;
    replacements.push({ start: match.index, end: match.index + full.length, text: classText });
  }

  if (replacements.length > 0) {
    replacements.sort((a, b) => b.start - a.start);
    for (const r of replacements) out = out.slice(0, r.start) + r.text + out.slice(r.end);
  }
  for (const ir of importsToRemove) {
    const importLineRegex = new RegExp(`\n?import\\s+(?:type\\s+)?\\{[^}]*\\b${escapeRegExp(ir.targetName)}\\b[^}]*\\}\\s*from\\s*['\"]${escapeRegExp(ir.importRel)}['\"];?\n?`, 'g');
    out = out.replace(importLineRegex, '\n');
  }
  return out;
}

function tsEnumToGdscriptEnum(ts: string, name: string): string {
  // Remove export, enum, chaves e espaços e quaisquer comentários
  let body = ts
    .replace(/export\s+enum\s+"?([\w_]+)"?\s*{/, '')
    .replace(/}/, '')
    .trim();
  body = stripComments(body);
  const lines = body
    .split(',')
    .map(l => l.trim())
    .filter(Boolean)
    .filter(l => !/^\/\//.test(l));
  let gd = `enum ${name} {\n`;
  lines.forEach((l, i) => {
    const key = l.replace(/\s*=.*$/, '');
    if (!key) return;
    gd += `    ${key} = ${i},\n`;
  });
  gd += '}\n';
  return gd;
}

type Prop = { name: string; type: string; tsType?: string; numHint?: 'int' | 'float' };

function generateGdClass(name: string, props: Prop[]): string {
  let gd = `class ${name}:\n`;
  if (props.length > 0) {
    for (const p of props) {
      gd += `    var ${p.name}: ${p.type}\n`;
    }
    gd += `\n    func _init(`;
    gd += props.map(p => `_${p.name}: ${p.type} = ${p.type === 'String' ? '""' : (p.type === 'bool' ? 'false' : (p.type === 'float' ? '0.0' : (p.type === 'int' ? '0' : (p.type === 'Array' ? '[]' : (p.type === 'Dictionary' ? '{}' : 'null'))) ))}`).join(', ');
    gd += `):\n`;
    for (const p of props) {
      gd += `        ${p.name} = _${p.name}\n`;
    }
    gd += `\n    func to_dict() -> Dictionary:\n`;
    gd += `        var d: Dictionary = {}\n`;
    for (const p of props) {
      gd += `        d["${p.name}"] = ${p.name}\n`;
    }
    gd += `        return d\n`;

    // Static from() coercer for typed usage from generic payloads
    gd += `\n    static func from(value: Variant) -> ${name}:\n`;
    gd += `        if typeof(value) == TYPE_OBJECT and value is ${name}:\n`;
    gd += `            return value\n`;
    gd += `        if typeof(value) == TYPE_DICTIONARY:\n`;
    gd += `            var raw: Dictionary = value\n`;
    gd += `            var obj := ${name}.new()\n`;
    for (const p of props) {
      const def = p.type === 'String' ? '""' : (p.type === 'bool' ? 'false' : (p.type === 'float' ? '0.0' : (p.type === 'int' ? '0' : (p.type === 'Array' ? '[]' : (p.type === 'Dictionary' ? '{}' : 'null')) )));
      if (name === 'CharacterResponse' && p.name === 'instancePath') {
        gd += `            obj.instancePath = raw.get("instancePath", raw.get("instance", ${def}))\n`;
        continue;
      }
      if (p.type === 'Array') {
        let itemTypeExpr = '';
        if (p.tsType) {
          const arrMatch = p.tsType.match(/^Array<([A-Za-z_][A-Za-z0-9_]*)>/);
          const brMatch = p.tsType.match(/^([A-Za-z_][A-Za-z0-9_]*)\[\]$/);
          itemTypeExpr = (arrMatch && arrMatch[1]) || (brMatch && brMatch[1]) || '';
        }
        gd += `            obj.${p.name} = []\n`;
        gd += `            if raw.has("${p.name}") and typeof(raw["${p.name}"]) == TYPE_ARRAY:\n`;
        gd += `                for it in raw["${p.name}"]:\n`;
        if (itemTypeExpr && /^[A-Z]/.test(itemTypeExpr)) {
          gd += `                    var conv = ${itemTypeExpr}.from(it)\n`;
          gd += `                    if conv != null:\n`;
          gd += `                        obj.${p.name}.append(conv)\n`;
          gd += `                    else:\n`;
          gd += `                        obj.${p.name}.append(it)\n`;
        } else {
          gd += `                    obj.${p.name}.append(it)\n`;
        }
        continue;
      }
      gd += `            obj.${p.name} = raw.get("${p.name}", ${def})\n`;
    }
    gd += `            return obj\n`;
    gd += `        return null\n`;
  } else {
    gd += `    pass\n`;
  }
  return gd;
}

function buildImportMap(ts: string): Map<string, string> {
  // Suporta: import { A, type B as C } from '...'
  //          import type { A, B } from '...'
  const importRegex = /import\s+(?:type\s+)?\{\s*([^}]+)\s*\}\s*from\s*['"]([^'\"]+)['"]/g;
  const importMap = new Map<string, string>();
  let m: RegExpExecArray | null;
  while ((m = importRegex.exec(ts)) !== null) {
    const names = m[1].split(',').map(s => s.trim()).filter(Boolean);
    const rel = m[2];
    for (let n of names) {
      // remove prefixo 'type ' dentro do bloco
      n = n.replace(/^type\s+/, '');
      // remove alias 'as Alias'
      n = n.replace(/\sas\s+.+$/, '');
      importMap.set(n.trim(), rel);
    }
  }
  return importMap;
}

function collectClassPropsFromContent(ts: string, className: string, filePath: string, seen: Set<string> = new Set()): Prop[] {
  if (seen.has(className)) return [];
  seen.add(className);
  const importMap = buildImportMap(ts);
  const declRegex1 = new RegExp(`export\\s+class\\s+${className}([^\\{]*)\\{`);
  const declRegex2 = new RegExp(`(^|\n)class\\s+${className}([^\\{]*)\\{`);
  const declMatch = ts.match(declRegex1) || ts.match(declRegex2);
  const body = getClassBody(ts, className) ?? '';
  const own = extractTsProps(body).map(p => ({ name: p.name, type: tsTypeToGdType(p.type, p.numericHint), tsType: p.type, numHint: p.numericHint }));
  let merged: Prop[] = [...own];
  if (declMatch) {
    const declTail = declMatch[1];
    const baseMatch = declTail.match(/extends\s+(\w+)/);
    if (baseMatch) {
      const baseName = baseMatch[1];
      let baseProps: Prop[] = [];
      const rel = importMap.get(baseName);
      if (rel) {
        const resolved = path.resolve(path.dirname(filePath), rel.endsWith('.ts') ? rel : rel + '.ts');
        if (fs.existsSync(resolved)) {
          const baseContent = fs.readFileSync(resolved, 'utf-8');
          baseProps = collectClassPropsFromContent(baseContent, baseName, resolved, seen);
        }
      } else {
        // Base na mesma unidade
        baseProps = collectClassPropsFromContent(ts, baseName, filePath, seen);
      }
      const map = new Map<string, { type: string; tsType?: string; numHint?: 'int'|'float' }>();
      for (const p of baseProps) map.set(p.name, { type: p.type, tsType: p.tsType, numHint: p.numHint });
      for (const p of merged) map.set(p.name, { type: p.type, tsType: p.tsType, numHint: p.numHint });
      merged = Array.from(map.entries()).map(([name, v]) => ({ name, type: v.type, tsType: v.tsType, numHint: v.numHint }));
    }
  }
  return merged;
}

function tsClassToGdscriptClass(ts: string, name: string, filePath: string): string {
  // Caso especial: gerar WebsocketMessage com data genérica (Variant) e helpers
  if (name === 'WebsocketMessage') {
    return [
      `class WebsocketMessage:`,
      `    var type: int`,
      `    var data: Variant`,
      ``,
      `    func _init(_type: int = 0, _data: Variant = null):`,
      `        type = _type`,
      `        data = _data`,
      ``,
      `    func to_dict() -> Dictionary:`,
      `        var d: Dictionary = {}`,
      `        d["type"] = type`,
      `        var payload = data`,
      `        if typeof(payload) == TYPE_OBJECT and payload != null and payload.has_method("to_dict"):
            payload = payload.to_dict()`,
      `        d["data"] = payload`,
      `        return d`,
      ``,
      `    func _to_string() -> String:`,
      `        var payload_data = data`,
      `        if typeof(payload_data) == TYPE_OBJECT and payload_data != null and payload_data.has_method("to_dict"):
            payload_data = payload_data.to_dict()`,
      `        var json_obj := {`,
      `            "type": type,`,
      `            "data": payload_data,`,
      `        }`,
      `        return JSON.stringify(json_obj)`,
      ``,
    ].join('\n');
  }
  const props = collectClassPropsFromContent(ts, name, filePath);
  return generateGdClass(name, props);
}

function getClassBody(ts: string, className: string): string | null {
  const startDeclIdx = ts.indexOf(`class ${className}`);
  if (startDeclIdx === -1) return null;
  const openIdx = ts.indexOf('{', startDeclIdx);
  if (openIdx === -1) return null;
  let depth = 1;
  let i = openIdx;
  while (i < ts.length - 1 && depth > 0) {
    i++;
    const ch = ts[i];
    if (ch === '{') depth++;
    else if (ch === '}') depth--;
  }
  if (depth !== 0) return null;
  return ts.slice(openIdx + 1, i);
}

function tsTypeToGdType(type: string, hint?: 'int' | 'float'): string {
  switch (type) {
    case 'number': return hint ?? 'float';
    case 'string': return 'String';
    case 'boolean': return 'bool';
    case 'any': return 'Variant';
    default:
      if (type === 'WebsocketEvents') return 'int';
      if (type === 'Direction') return 'int';
      if (type === 'Date') return 'Variant';
      // Mapear parâmetros genéricos (e.g., T) para Variant (genérico)
      if (/^[A-Z]$/.test(type)) return 'Variant';
      if (/^Array<.+>$/.test(type)) return 'Array';
      if (type.endsWith('[]')) return `Array`; // simplificação
      if (type === 'object' || /^Record<.+>$/.test(type)) return 'Dictionary';
      return 'Variant';
  }
}

function stripComments(ts: string): string {
  // Remove block comments /* ... */ and line comments // ...
  let out = ts.replace(/\/\*[\s\S]*?\*\//g, '');
  out = out.replace(/(^|\s)\/\/.*$/gm, '$1');
  return out;
}

function flattenExtendedClasses(ts: string, filePath: string): string {
  // Achata classes com 'extends' em uma única declaração plana.
  // Benefício: simplifica cópia para auth-server e evita dependências
  // implícitas de herança durante parsing em etapas posteriores.
  // Processa todas as classes exportadas que usam 'extends <Base>' e substitui por classe plana com props mescladas
  const importRegex = /import\s*{\s*([^}]+)\s*}\s*from\s*['"]([^'\"]+)['"]/g;
  const importMap = new Map<string, string>();
  let m: RegExpExecArray | null;
  while ((m = importRegex.exec(ts)) !== null) {
    const names = m[1].split(',').map(s => s.trim()).filter(Boolean);
    const rel = m[2];
    for (const n of names) importMap.set(n, rel);
  }

  const classRegex = /export\s+class\s+(\w+)\s+extends\s+(\w+)[^{]*\{([\s\S]*?)\}/g;
  let out = ts;
  let clsMatch: RegExpExecArray | null;
  const replacements: Array<{ start: number; end: number; text: string }> = [];
  const importsToRemove: Array<{ baseName: string; importRel: string }> = [];

  while ((clsMatch = classRegex.exec(ts)) !== null) {
    const full = clsMatch[0];
    const clsName = clsMatch[1];
    const baseName = clsMatch[2];
    const ownBody = clsMatch[3];
    const importRel = importMap.get(baseName);
    let baseProps: Array<{ name: string; type: string; optional: boolean }> = [];
    if (importRel) {
      const resolved = path.resolve(path.dirname(filePath), importRel.endsWith('.ts') ? importRel : importRel + '.ts');
      if (fs.existsSync(resolved)) {
        const baseContent = fs.readFileSync(resolved, 'utf-8');
        const baseBody = getClassBody(baseContent, baseName);
        if (baseBody) {
          baseProps = extractTsProps(baseBody);
        }
      }
    }
    const ownProps = extractTsProps(ownBody);
    const mergedMap = new Map<string, { type: string; optional: boolean }>();
    for (const p of baseProps) mergedMap.set(p.name, { type: p.type, optional: p.optional });
    for (const p of ownProps) mergedMap.set(p.name, { type: p.type, optional: p.optional });
    const merged = Array.from(mergedMap.entries()).map(([name, v]) => ({ name, type: v.type, optional: v.optional }));

    let classText = `export class ${clsName} {\n`;
    for (const p of merged) {
      classText += `  ${p.name}${p.optional ? '?' : ''}: ${p.type};\n`;
    }
    classText += `}`;

    const start = clsMatch.index;
    const end = clsMatch.index + full.length;
    replacements.push({ start, end, text: classText });

    // Acumula import para remoção após aplicar substituições
    if (importRel) {
      importsToRemove.push({ baseName, importRel });
    }
  }

  // Aplicar substituições (do fim para o início para preservar índices)
  if (replacements.length > 0) {
    replacements.sort((a, b) => b.start - a.start);
    for (const r of replacements) {
      out = out.slice(0, r.start) + r.text + out.slice(r.end);
    }
  }
  // Remove imports das classes bases já substituídas
  for (const ir of importsToRemove) {
    const importLineRegex = new RegExp(`\\n?import\\s*{[^}]*\\b${ir.baseName}\\b[^}]*}\\s*from\\s*['\"]${escapeRegExp(ir.importRel)}['\"];?\\n?`, 'g');
    out = out.replace(importLineRegex, '\n');
  }
  return out;
}

function extractTsProps(body: string): Array<{ name: string; type: string; optional: boolean; numericHint?: 'int' | 'float' }> {
  const lines = body.split(/\r?\n/).filter(l => l.trim().length > 0);
  const result: Array<{ name: string; type: string; optional: boolean; numericHint?: 'int' | 'float' }> = [];
  for (const rawLine of lines) {
    // Preserve inline comments for numeric hint detection
    const line = rawLine.trim();
    const propMatch = line.match(/^(?:public|private|protected|readonly)?\s*(\w+)(\??)\s*:\s*([^;]+);/);
    if (propMatch) {
      const name = propMatch[1];
      const optional = propMatch[2] === '?';
      const type = propMatch[3].trim();
      let numericHint: 'int' | 'float' | undefined;
      const commentMatch = line.match(/\/\/\s*(Float|Integer)/i);
      if (commentMatch) {
        const val = commentMatch[1].toLowerCase();
        if (val === 'float') numericHint = 'float';
        if (val === 'integer') numericHint = 'int';
      }
      result.push({ name, type, optional, numericHint });
    }
  }
  return result;
}

function escapeRegExp(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function addSemicolonsForConstDeclarations(ts: string): string {
  // Garante pontos-e-vírgula após objetos/arrays exportados.
  // Ajuda a evitar diffs ruidosos e melhora parsing em algumas toolchains.
  // Insere ';' após declarações export const ... = {...} ou [...]
  const regex = /export\s+const\s+\w+\s*=\s*(\{|\[)/g;
  const replacements: Array<{ insertPos: number }> = [];
  let match: RegExpExecArray | null;
  while ((match = regex.exec(ts)) !== null) {
    const openChar = match[1];
    const startIdx = match.index + match[0].length - 1; // aponta para '{' ou '['
    let depth = 1;
    let i = startIdx;
    while (i < ts.length - 1 && depth > 0) {
      i++;
      const ch = ts[i];
      if (ch === openChar) depth++;
      else if (openChar === '{' && ch === '}') depth--;
      else if (openChar === '[' && ch === ']') depth--;
    }
    if (depth === 0) {
      // i é o índice do '}' ou ']'
      // Procurar próximo caractere não espaço/nova linha
      let j = i + 1;
      while (j < ts.length && /[\s]/.test(ts[j])) j++;
      if (j >= ts.length || ts[j] !== ';') {
        // Inserir ';' logo após o fechamento
        replacements.push({ insertPos: i + 1 });
      }
    }
  }
  if (replacements.length === 0) return ts;
  // Aplicar inserções do fim para o começo
  let out = ts;
  replacements.sort((a, b) => b.insertPos - a.insertPos);
  for (const r of replacements) {
    out = out.slice(0, r.insertPos) + ';' + out.slice(r.insertPos);
  }
  return out;
}

function formatForAuthServer(ts: string): string {
  // Normaliza espaços/linhas, adiciona respiros ao redor de classes para
  // leitura mais fluida no repositório auth-server.
  // Remover espaços em branco no fim das linhas
  const lines = ts.split(/\r?\n/).map(l => l.replace(/[ \t]+$/, ''));
  const out: string[] = [];
  let inClass = false;
  let braceDepth = 0;

  const isClassStart = (line: string) => /^export\s+class\s+\w+[^\{]*\{\s*$/.test(line);

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (isClassStart(line)) {
      // Garantir uma linha em branco antes da classe
      if (out.length === 0 || out[out.length - 1].trim() !== '') {
        out.push('');
      }
      inClass = true;
      // Atualiza profundidade de chaves
      braceDepth = (line.match(/\{/g)?.length || 0) - (line.match(/\}/g)?.length || 0);
      out.push(line);
      // Inserir linha em branco logo após a abertura da classe
      out.push('');
      continue;
    }

    if (inClass) {
      // Atualiza profundidade de chaves com a linha atual
      braceDepth += (line.match(/\{/g)?.length || 0) - (line.match(/\}/g)?.length || 0);
      // Antes de fechar a classe, garantir linha em branco
      if (line.trim() === '}') {
        if (out.length > 0 && out[out.length - 1].trim() !== '') {
          out.push('');
        }
      }
      out.push(line);
      if (braceDepth <= 0) {
        // Final da classe: inserir uma linha em branco
        if (out.length > 0 && out[out.length - 1].trim() !== '') {
          out.push('');
        }
        inClass = false;
        braceDepth = 0;
      }
      continue;
    }

    out.push(line);
  }

  // Compactar múltiplas linhas em branco para no máximo uma
  let result = out.join('\n').replace(/\n{3,}/g, '\n\n');
  // Garantir uma linha em branco ao final do arquivo
  result = result.replace(/\n+$/, '\n\n');
  return result;
}

function tsObjectToGdscriptDict(ts: string, name: string): string {
  // Encontra a posição do export const <name> = {
  const startRegex = new RegExp(`export\\s+const\\s+${name}\\s*=\\s*{`);
  const startMatch = ts.match(startRegex);
  if (!startMatch) return '';
  const startIdx = ts.indexOf(startMatch[0]) + startMatch[0].length - 1;
  // Faz parsing manual para encontrar o fechamento correto do objeto
  let open = 1;
  let endIdx = startIdx;
  while (open > 0 && endIdx < ts.length - 1) {
    endIdx++;
    if (ts[endIdx] === '{') open++;
    if (ts[endIdx] === '}') open--;
  }
  let body = ts.slice(startIdx, endIdx + 1);
  body = stripComments(body);
  // Remove aspas simples e duplas das chaves e valores
  body = body.replace(/(['"])?([a-zA-Z0-9_]+)\1\s*:/g, '"$2":');
  body = body.replace(/: ?'([a-zA-Z0-9_]+)'/g, ': "$1"');
  // Ajusta vírgulas finais
  body = body.replace(/,\s*}/g, '}');
  // Garante fechamento correto de todas as chaves
  let open2 = 0, close2 = 0;
  for (const c of body) {
    if (c === '{') open2++;
    if (c === '}') close2++;
  }
  while (close2 < open2) {
    body += '}';
    close2++;
  }
  return `const ${name} = ${body}`;
}

function tsArrayToGdscriptArray(ts: string, name: string): string {
  const startRegex = new RegExp(`export\\s+const\\s+${name}\\s*=\\s*\\[`);
  const startMatch = ts.match(startRegex);
  if (!startMatch) return '';
  const startIdx = ts.indexOf(startMatch[0]) + startMatch[0].length - 1; // at '['

  let openSquare = 1;
  let openCurly = 0;
  let endIdx = startIdx;
  while (endIdx < ts.length - 1 && openSquare > 0) {
    endIdx++;
    const ch = ts[endIdx];
    if (ch === '[') openSquare++;
    if (ch === ']') openSquare--;
    if (ch === '{') openCurly++;
    if (ch === '}') openCurly--;
  }
  let body = ts.slice(startIdx, endIdx + 1);
  body = stripComments(body);
  // Quote object keys and normalize quotes for strings
  body = body.replace(/(['"])??([a-zA-Z0-9_]+)\1\s*:/g, '"$2":');
  body = body.replace(/'([^']*)'/g, '"$1"');
  // Remove trailing commas before ] or }
  body = body.replace(/,\s*([\]}])/g, '$1');
  return `const ${name} = ${body}`;
}

function tsFunctionToGdscriptFunction(ts: string, name: string): string {
  // Converte uma função TS exportada para uma função GDScript.
  // Foco em extrair 'return { ... }' quando presente, tornando dicionários
  // válidos e simples de usar no lado do Godot.
  // Extrai assinatura e corpo da função exportada
  const funcMatch = ts.match(new RegExp(`export\\s+function\\s+${name}\\s*\\(([^)]*)\\)\\s*(:\\s*[^{]+)?\\s*{([\\s\\S]*?)}\\s*$`, 'm'));
  if (!funcMatch) return '';
  const args = funcMatch[1].trim();
  // Remove tipagem dos argumentos
  const gdArgs = args
    ? args.split(',').map(a => a.split(':')[0].trim()).filter(Boolean).join(', ')
    : '';
  let body = funcMatch[3].trim();
  body = stripComments(body);

  // Extrai apenas o return da função
  const returnMatch = body.match(/return\s+{([\s\S]*?)}/);
  if (returnMatch) {
    // Converte para dicionário GDScript e garante fechamento correto
    let props = returnMatch[1]
      .split(',')
      .map((p: string) => {
        const [k, v] = p.split(':').map((s: string) => s.trim());
        if (k && v) return `"${k}": ${v}`;
        return '';
      })
      .filter(Boolean)
      .join(', ');
    // Corrige dicionário vazio ou aberto
    if (props.trim().endsWith('{')) props += ' }';
    if (!props.trim().endsWith('}')) props += ' }';
    return `func ${name}(${gdArgs}):\n    return { ${props} }`;
  }

  // Se não encontrar return de objeto, retorna corpo limpo
  body = body.replace(/\s*:\s*[^\s]+/g, '');
  body = body.replace(/[{};]/g, '');
  body = body.replace(/any/g, '');
  body = body.split('\n').map(l => '    ' + l.trim()).join('\n');
  return `func ${name}(${gdArgs}):\n${body}`;
}

function tsTypeAliasToGdscriptClass(ts: string, aliasName: string, targetName: string, filePath: string): string {
  let props: Prop[] = [];
  const targetDeclRegex = new RegExp(`export\\s+class\\s+${targetName}\\b|(^|\\n)class\\s+${targetName}\\b`);
  if (targetDeclRegex.test(ts)) {
    props = collectClassPropsFromContent(ts, targetName, filePath);
  } else {
    const importMap = buildImportMap(ts);
    const rel = importMap.get(targetName);
    if (rel) {
      const resolved = path.resolve(path.dirname(filePath), rel.endsWith('.ts') ? rel : rel + '.ts');
      if (fs.existsSync(resolved)) {
        const targetContent = fs.readFileSync(resolved, 'utf-8');
        props = collectClassPropsFromContent(targetContent, targetName, resolved);
      }
    }
  }
  return generateGdClass(aliasName, props);
}

function tsIntersectionAliasToGdscriptClass(ts: string, aliasName: string, targetName: string, inlineBody: string, filePath: string): string {
  // Coleta props da classe alvo + props do objeto inline
  let targetProps: Prop[] = [];
  const targetDeclRegex = new RegExp(`export\\s+class\\s+${targetName}\\b|(^|\\n)class\\s+${targetName}\\b`);
  if (targetDeclRegex.test(ts)) {
    targetProps = collectClassPropsFromContent(ts, targetName, filePath);
  } else {
    const importMap = buildImportMap(ts);
    const rel = importMap.get(targetName);
    if (rel) {
      const resolved = path.resolve(path.dirname(filePath), rel.endsWith('.ts') ? rel : rel + '.ts');
      if (fs.existsSync(resolved)) {
        const targetContent = fs.readFileSync(resolved, 'utf-8');
        targetProps = collectClassPropsFromContent(targetContent, targetName, resolved);
      }
    }
  }
  const extraTsProps = extractTsProps(inlineBody).map(p => ({ name: p.name, type: tsTypeToGdType(p.type, p.numericHint), tsType: p.type, numHint: p.numericHint }));
  const mergedMap = new Map<string, Prop>();
  for (const p of targetProps) mergedMap.set(p.name, p);
  for (const p of extraTsProps) mergedMap.set(p.name, p);
  const merged = Array.from(mergedMap.values());
  return generateGdClass(aliasName, merged);
}

function processFile(file: string) {
  // Para cada arquivo TS em shared:
  // - Emite enums, objetos e arrays como construções GDScript
  // - Converte classes e funções exportadas para GDScript
  // - Escreve saída em client/shared com mesmo basename
  const contentRaw = fs.readFileSync(file, 'utf-8');
  const content = stripComments(contentRaw);
  let output = '';

  // Enums
  const enumRegex = /export\s+enum\s+(\w+)\s*{([\s\S]*?)}/g;
  let enumMatch;
  while ((enumMatch = enumRegex.exec(content)) !== null) {
    const name = enumMatch[1];
    const enumContent = `export enum ${name} {${enumMatch[2]}}`;
    output += tsEnumToGdscriptEnum(enumContent, name) + '\n';
  }

  // Objetos
  const objRegex = /export\s+const\s+(\w+)\s*=\s*({[\s\S]*?})/g;
  let objMatch;
  while ((objMatch = objRegex.exec(content)) !== null) {
    const name = objMatch[1];
    output += tsObjectToGdscriptDict(content, name) + '\n';
  }

  // Arrays (inclui arrays de objetos)
  const arrRegex = /export\s+const\s+(\w+)\s*=\s*\[/g;
  let arrMatch;
  while ((arrMatch = arrRegex.exec(content)) !== null) {
    const name = arrMatch[1];
    const arrOut = tsArrayToGdscriptArray(content, name);
    if (arrOut) output += arrOut + '\n';
  }

  // Classes (suporta genéricos e qualquer conteúdo entre o nome e '{')
  const classRegex = /export\s+class\s+(\w+)[^{]*{([\s\S]*?)}/g;
  let classMatch;
  while ((classMatch = classRegex.exec(contentRaw)) !== null) {
    const name = classMatch[1];
    output += tsClassToGdscriptClass(contentRaw, name, file) + '\n';
  }

  // Funções
  const funcRegex = /export\s+function\s+(\w+)\s*\([^)]*\)\s*(:\s*[^{]+)?\s*{[\s\S]*?}/g;
  let funcMatch;
  while ((funcMatch = funcRegex.exec(content)) !== null) {
    const name = funcMatch[1];
    output += tsFunctionToGdscriptFunction(content, name) + '\n';
  }

  // Type aliases simples: export type A = B;
  const typeAliasRegex = /export\s+type\s+(\w+)\s*=\s*(\w+)\s*;/g;
  let aliasMatch: RegExpExecArray | null;
  while ((aliasMatch = typeAliasRegex.exec(contentRaw)) !== null) {
    const aliasName = aliasMatch[1];
    const targetName = aliasMatch[2];
    const aliasOut = tsTypeAliasToGdscriptClass(contentRaw, aliasName, targetName, file);
    if (aliasOut) output += aliasOut + '\n';
  }

  // Type aliases com interseção: export type A = B & { ... };
  const intersectionAliasRegex2 = /export\s+type\s+(\w+)\s*=\s*(\w+)\s*&\s*{([\s\S]*?)}\s*;/g;
  while ((aliasMatch = intersectionAliasRegex2.exec(contentRaw)) !== null) {
    const aliasName = aliasMatch[1];
    const targetName = aliasMatch[2];
    const inlineBody = aliasMatch[3];
    const aliasOut = tsIntersectionAliasToGdscriptClass(contentRaw, aliasName, targetName, inlineBody, file);
    if (aliasOut) output += aliasOut + '\n';
  }

  if (output.trim().length > 0) {
    const baseName = path.basename(file, '.ts');
    const outPath = path.join(OUTPUT_DIR, `${baseName}.gd`);
    writeFileIfChanged(outPath, output.trim() + '\n');
  }
}

function main() {
  // Gera arquivos para o client (Godot)
  if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  const files = fs.readdirSync(SHARED_DIR).filter(f => f.endsWith('.ts'));
  for (const file of files) {
    processFile(path.join(SHARED_DIR, file));
  }

  // Copia arquivos para o auth-server/shared
  if (!fs.existsSync(AUTH_SHARED_DIR)) fs.mkdirSync(AUTH_SHARED_DIR, { recursive: true });
  for (const file of files) {
    const src = path.join(SHARED_DIR, file);
    const dest = path.join(AUTH_SHARED_DIR, file);
    copyFileIfChanged(src, dest);
  }
}

main();
